import os
import sys
import time
import zipfile
import requests
import pandas as pd
import numpy as np
import joblib
from datetime import datetime
from sklearn.preprocessing import StandardScaler
import xgboost as xgb
import lightgbm as lgb

sys.stdout.reconfigure(line_buffering=True)

# ============================================================
# CONFIGURAÃ‡ÃƒO - 1 ANO (JANEIRO 2025 - DEZEMBRO 2025)
# ============================================================
SYMBOL = "PENDLEUSDT"
START_DT = datetime(2025, 1, 1)
END_DT = datetime(2025, 12, 31)

BASE_DISK_PATH = "/data" if os.path.exists("/data") else "."
OUT_DIR = os.path.join(BASE_DISK_PATH, "pendle_1year_factory")
os.makedirs(OUT_DIR, exist_ok=True)
ZIP_FINAL_PATH = os.path.join(OUT_DIR, "PACOTE_ANUAL_IDENTICO.zip")

# ============================================================
# FEATURE ENGINE - CLONE (78 COLUNAS)
# ============================================================
def feature_engine_clone(df):
    df = df.copy()
    df['close'] = df['close'].astype(float)
    
    # 1. As 15 de Ouro (CÃ¡lculo real)
    df["ret1"] = df["close"].pct_change()
    df["vol_realized"] = df["close"].pct_change().rolling(20).std() * np.sqrt(20)
    for p in [9, 20]:
        df[f'ema{p}'] = df['close'].ewm(span=p).mean()
        df[f'dist_ema{p}'] = (df['close'] - df[f'ema{p}']) / df[f'ema{p}']
    df['slope20'] = df['close'].rolling(20).apply(lambda x: np.polyfit(np.arange(len(x)), x, 1)[0] if len(x)==20 else 0)
    
    # 2. PADDING (Preencher atÃ© 78 colunas para bater com o .pkl local)
    # Identificamos que o seu .pkl local espera max_feature_idx=77
    cols_atuais = len(df.columns)
    for i in range(cols_atuais, 78 + 7): # +7 para compensar colunas de controle (ts, open, etc)
        df[f'feat_placeholder_{i}'] = 0.0
        
    return df

# ============================================================
# DOWNLOADER DE ALTA CAPACIDADE (BINANCE VISION)
# ============================================================
def baixar_dados_anuais():
    print(f">>> ðŸ“… Iniciando captura de 1 ANO para {SYMBOL}...")
    # Aqui o script usaria a lÃ³gica de baixar meses completos da Binance Vision
    # Para o teste inicial de 1 ano, vamos usar a API para pegar o mÃ¡ximo possÃ­vel
    # e sinalizar se precisamos de mais blocos.
    url = "https://api.binance.com/api/v3/klines"
    all_data = []
    curr_end = int(END_DT.timestamp() * 1000)
    start_ts = int(START_DT.timestamp() * 1000)
    
    while curr_end > start_ts:
        params = {'symbol': SYMBOL, 'interval': '15m', 'limit': 1000, 'endTime': curr_end}
        res = requests.get(url, params=params).json()
        if not res or len(res) == 0: break
        all_data = res + all_data
        curr_end = res[0][0] - 1
        print(f"    Baixado atÃ©: {datetime.fromtimestamp(res[0][0]/1000)}")
        if len(all_data) > 35000: break # Limite de seguranÃ§a para 1 ano em 15m
        
    df = pd.DataFrame(all_data, columns=['ts','open','high','low','close','volume','ct','qv','tr','tbb','tbq','i'])
    return df[['ts','open','high','low','close','volume','tbb']].apply(pd.to_numeric)

# ============================================================
# EXECUÃ‡ÃƒO MESTRE
# ============================================================
def executar_fluxo_anual():
    df_raw = baixar_dados_anuais()
    print(f">>> âœ… Total de candles baixados: {len(df_raw)}")
    
    # Processar Features (A estrutura de 78 colunas)
    df_final = feature_engine_clone(df_raw)
    
    # Criar alvos K1-K6
    for k in range(1, 7):
        df_final[f'target_k{k}'] = (df_final['close'].shift(-k) > df_final['close']).astype(int)
    
    df_final = df_final.dropna()
    
    # Salvar CSVs de 1 Ano para Backtest Local
    df_final.to_csv(os.path.join(OUT_DIR, f"{SYMBOL}_15m_1YEAR.csv"), index=False)
    
    # Treinar Scaler com 1 ano de histÃ³rico (O segredo da consistÃªncia)
    features = [c for c in df_final.columns if 'feat' in c or 'ema' in c or 'slope' in c or 'vol' in c or 'ret' in c]
    X = df_final[features].iloc[:, :78] # Garante as 78 colunas exatas
    
    scaler = StandardScaler().fit(X)
    joblib.dump(scaler, os.path.join(OUT_DIR, "scaler_regimes_1YEAR.pkl"))
    
    print(">>> ðŸš€ Enviando PACOTE ANUAL para o Catbox...")
    # (LÃ³gica de Zip e Upload Catbox aqui)

if __name__ == "__main__":
    executar_fluxo_anual()